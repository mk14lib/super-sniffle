#include <iostream> // ఇన్పుట్/అవుట్పుట్ కోసం
#include <vector>   // వెక్టర్స్ కోసం
#include <queue>    // ప్రయారిటీ క్యూ కోసం
#include <limits>   // numeric_limits కోసం (అనంతం)

// డిజేక్స్ట్రాస్ అల్గోరిథం
// graph: అడ్జాసెన్సీ లిస్ట్ (నోడ్, వెయిట్) జతలతో కూడిన వెక్టర్ల వెక్టర్
// start_node: ప్రారంభ నోడ్
std::vector<int> dijkstra(const std::vector<std::vector<std::pair<int, int>>>& graph, int start_node) {
    int num_nodes = graph.size();
    // ప్రతి నోడ్‌కు ప్రారంభం నుండి అతి తక్కువ దూరాన్ని నిల్వ చేయడానికి
    // అన్ని దూరాలను అనంతం (infinity) గా ప్రారంభించండి.
    // std::numeric_limits<int>::max() అనేది int యొక్క గరిష్ట విలువను ఇస్తుంది, అనంతంలా పనిచేస్తుంది.
    std::vector<int> dist(num_nodes, std::numeric_limits<int>::max());

    // ప్రయారిటీ క్యూ: ఇది జతలను (దూరం, నోడ్) నిల్వ చేస్తుంది.
    // డిఫాల్ట్‌గా std::priority_queue పెద్ద ఎలిమెంట్‌ను పైన ఉంచుతుంది.
    // మనం చిన్న ఎలిమెంట్‌ను (అంటే తక్కువ దూరం) పైన ఉంచాలనుకుంటున్నాం, కాబట్టి std::greater ఉపయోగిస్తాం.
    // pair.first అనేది దూరం, దీని ద్వారా ప్రయారిటీ క్యూ సార్ట్ చేస్తుంది.
    std::priority_queue<std::pair<int, int>,
                         std::vector<std::pair<int, int>>,
                         std::greater<std::pair<int, int>>> pq;

    // ప్రారంభ నోడ్‌కు దూరం 0 గా సెట్ చేయండి.
    dist[start_node] = 0;
    // ప్రయారిటీ క్యూలోకి (దూరం, నోడ్) జతను జోడించండి.
    pq.push({0, start_node});

    // ప్రయారిటీ క్యూ ఖాళీగా లేనంత వరకు లూప్ కొనసాగించండి.
    while (!pq.empty()) {
        // ప్రయారిటీ క్యూ నుండి అతి తక్కువ దూరం ఉన్న నోడ్‌ను తీసివేయండి.
        int d = pq.top().first;  // ఈ నోడ్‌కు చేరుకోవడానికి ప్రస్తుత అతి తక్కువ దూరం
        int u = pq.top().second; // నోడ్ ID
        pq.pop();

        // ఒకవేళ మనం ఇప్పటికే ఈ నోడ్‌కు అంతకంటే తక్కువ దూరాన్ని కనుగొన్నట్లయితే,
        // ఈ పాత ఎంట్రీని విస్మరించండి. (ఇది డూప్లికేట్ ఎంట్రీలను నివారిస్తుంది)
        if (d > dist[u]) {
            continue;
        }

        // ప్రస్తుత నోడ్ 'u' యొక్క అన్ని పొరుగు నోడ్‌లను పరిశీలించండి.
        // graph[u] లో {neighbor_node, weight} జతలు ఉంటాయి.
        for (const auto& edge : graph[u]) {
            int v = edge.first;     // పొరుగు నోడ్
            int weight = edge.second; // u నుండి v కు ఎడ్జ్ యొక్క బరువు

            // ఒకవేళ u ద్వారా v కి వెళ్ళే మార్గం v యొక్క ప్రస్తుత దూరం కంటే తక్కువగా ఉంటే,
            if (dist[u] + weight < dist[v]) {
                dist[v] = dist[u] + weight; // v యొక్క దూరాన్ని అప్‌డేట్ చేయండి
                pq.push({dist[v], v});      // అప్‌డేట్ చేయబడిన దూరంతో v ని PQ లోకి జోడించండి
            }
        }
    }

    return dist; // ప్రారంభ నోడ్ నుండి ప్రతి నోడ్‌కు అతి తక్కువ దూరాలను తిరిగి ఇవ్వండి
}

int main() {
    // గ్రాఫ్ యొక్క అడ్జాసెన్సీ లిస్ట్.
    // నోడ్‌లు 0 నుండి 4 వరకు ఉన్నాయి.
    // ప్రతి ఎలిమెంట్ graph[i] అనేది నోడ్ i కి కనెక్ట్ చేయబడిన
    // {పొరుగు నోడ్, ఎడ్జ్ వెయిట్} జతల వెక్టర్.
    // (0) --4-- (1)
    //  |       / |
    //  2      /  5
    //  |     /   |
    // (2) --1-- (3)
    //  |       /
    //  8      /
    //  |     /
    // (4) --3--
    std::vector<std::vector<std::pair<int, int>>> graph_example = {
        {{1, 4}, {2, 2}},     // 0 నుండి: (1, వెయిట్ 4), (2, వెయిట్ 2)
        {{0, 4}, {3, 5}},     // 1 నుండి: (0, వెయిట్ 4), (3, వెయిట్ 5)
        {{0, 2}, {3, 1}, {4, 8}}, // 2 నుండి: (0, వెయిట్ 2), (3, వెయిట్ 1), (4, వెయిట్ 8)
        {{1, 5}, {2, 1}, {4, 3}}, // 3 నుండి: (1, వెయిట్ 5), (2, వెయిట్ 1), (4, వెయిట్ 3)
        {{2, 8}, {3, 3}}      // 4 నుండి: (2, వెయిట్ 8), (3, వెయిట్ 3)
    };

    int start_node = 0;
    std::vector<int> shortest_distances = dijkstra(graph_example, start_node);

    std::cout << "ప్రారంభ నోడ్ '" << start_node << "' నుండి అతి తక్కువ దూరాలు:" << std::endl;
    for (int i = 0; i < shortest_distances.size(); ++i) {
        if (shortest_distances[i] == std::numeric_limits<int>::max()) {
            std::cout << "నోడ్ " << i << ": అనంతం (చేరుకోలేనిది)" << std::endl;
        } else {
            std::cout << "నోడ్ " << i << ": " << shortest_distances[i] << std::endl;
        }
    }
    // అంచనా అవుట్‌పుట్:
    // నోడ్ 0: 0
    // నోడ్ 1: 4
    // నోడ్ 2: 2
    // నోడ్ 3: 3
    // నోడ్ 4: 6

    return 0;
}
